<!doctype html>

<head>
  <meta charset="UTF-8">
  <title>vaadin-date-time-picker tests</title>
  <script src="../../web-component-tester/browser.js"></script>
  <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
  <link rel="import" href="../../test-fixture/test-fixture.html">
  <link rel="import" href="../vaadin-date-time-picker.html">
</head>

<body>
  <test-fixture id="default">
    <template>
      <vaadin-date-time-picker></vaadin-date-time-picker>
    </template>
  </test-fixture>

  <test-fixture id="initial-value">
    <template>
      <vaadin-date-time-picker value="2019-09-16T15:00"></vaadin-date-time-picker>
    </template>
  </test-fixture>

  <test-fixture id="theme-attribute">
    <template>
      <vaadin-date-time-picker theme="foo"></vaadin-date-time-picker>
    </template>
  </test-fixture>

  <test-fixture id="slotted-inputs">
    <template>
      <vaadin-date-time-picker>
        <vaadin-date-picker slot="date-picker"></vaadin-date-picker>
        <vaadin-time-picker slot="time-picker"></vaadin-time-picker>
      </vaadin-date-time-picker>
    </template>
  </test-fixture>

  <test-fixture id="lazy-slotted-inputs">
    <template>
      <vaadin-date-time-picker>
        <vaadin-date-picker slot="setAfterReady"></vaadin-date-picker>
        <vaadin-time-picker slot="setAfterReady"></vaadin-time-picker>
      </vaadin-date-time-picker>
    </template>
  </test-fixture>

  <test-fixture id="slotted-values">
    <template>
      <vaadin-date-time-picker>
        <vaadin-date-picker slot="date-picker" value="2019-09-16"></vaadin-date-picker>
        <vaadin-time-picker slot="time-picker" value="15:00"></vaadin-time-picker>
      </vaadin-date-time-picker>
    </template>
  </test-fixture>

  <test-fixture id="lazy-slotted-values">
    <template>
      <vaadin-date-time-picker>
        <vaadin-date-picker slot="setAfterReady" value="2019-09-16"></vaadin-date-picker>
        <vaadin-time-picker slot="setAfterReady" value="15:00"></vaadin-time-picker>
      </vaadin-date-time-picker>
    </template>
  </test-fixture>

  <test-fixture id="autofocus">
    <template>
      <vaadin-date-time-picker autofocus></vaadin-date-time-picker>
    </template>
  </test-fixture>

  <script>
    function changeInputValue(el, value) {
      el.value = value;
      el.dispatchEvent(new CustomEvent('change', {bubbles: true}));
    }

    describe('Basic features', () => {
      let dateTimePicker;
      let customField;
      let datePicker;
      let timePicker;

      beforeEach(() => {
        dateTimePicker = fixture('default');
        customField = dateTimePicker.$.customField;
        datePicker = customField.inputs[0];
        timePicker = customField.inputs[1];
      });

      it('should not expose class name globally', () => {
        expect(window.DateTimePicker).not.to.be.ok;
      });

      it('should have a valid version number', () => {
        expect(dateTimePicker.constructor.version).to.match(/^(\d+\.)?(\d+\.)?(\d+)(-(alpha|beta)\d+)?$/);
      });

      it('should have default value', () => {
        expect(dateTimePicker.value).to.equal('');
      });

      it('should convert null and undefined values to empty string', () => {
        dateTimePicker.value = '2019-09-19T08:26'; // init with valid value
        dateTimePicker.value = null;
        expect(dateTimePicker.value).to.equal('');

        dateTimePicker.value = '2019-09-19T08:26'; // init with valid value
        dateTimePicker.value = undefined;
        expect(dateTimePicker.value).to.equal('');
      });

      it('should notify value change', () => {
        const spy = sinon.spy();
        dateTimePicker.addEventListener('value-changed', spy);
        dateTimePicker.value = '2019-09-19T08:26';
        expect(spy).to.have.been.calledOnce;

        spy.reset();
        dateTimePicker.value = '';
        expect(spy).to.have.been.calledOnce;
      });

      it('should get value from custom field', () => {
        datePicker.value = '2019-09-19';
        timePicker.value = '15:00';
        dateTimePicker.__triggerCustomFieldValueUpdate();
        expect(dateTimePicker.value).to.equal('2019-09-19T15:00');
      });

      it('should delegate focus() to date picker', () => {
        dateTimePicker.focus();
        expect(datePicker.hasAttribute('focused')).to.be.true;
      });

      it('should focus date picker when autofocus is set', done => {
        dateTimePicker = fixture('autofocus');
        datePicker = dateTimePicker.__datePicker;
        requestAnimationFrame(() => {
          expect(datePicker.hasAttribute('focused')).to.be.true;
          done();
        });
      });

      describe('change event', () => {

        let spy;

        beforeEach(() => {
          spy = sinon.spy();
          dateTimePicker.addEventListener('change', spy);
        });

        it('should fire change on date picker change event', () => {
          changeInputValue(timePicker, '16:00');
          expect(spy).to.not.have.been.called;
          changeInputValue(datePicker, '2020-01-17');
          expect(spy).to.have.been.calledOnce;
          changeInputValue(datePicker, '');
          expect(spy).to.have.been.calledTwice;
        });

        it('should fire change on time picker change event', () => {
          changeInputValue(datePicker, '2020-01-17');
          expect(spy).to.not.have.been.called;
          changeInputValue(timePicker, '16:00');
          expect(spy).to.have.been.calledOnce;
          changeInputValue(timePicker, '');
          expect(spy).to.have.been.calledTwice;
        });

        it('should not fire change on programmatic value change', () => {
          dateTimePicker.value = '2020-01-17T16:00';
          expect(spy).to.not.have.been.called;
        });

        it('should not fire change on programmatic value change after manual one', () => {
          dateTimePicker.value = '2020-01-17T16:00'; // Init with valid value
          changeInputValue(datePicker, '2020-01-20');
          spy.reset();
          dateTimePicker.value = '2020-01-10T12:00';
          expect(spy).to.not.have.been.called;
        });

        it('should not fire change on programmatic value change after partial manual one', () => {
          changeInputValue(datePicker, '2020-01-17');
          // Time picker has no value so date time picker value is still empty
          dateTimePicker.value = '2020-01-17T16:00';
          expect(spy).to.not.have.been.called;
        });
      });

      describe('value property formats', () => {

        it('should accept ISO format', () => {
          var date = new Date(0, 1, 3, 8, 30, 0);

          date.setFullYear(0);
          dateTimePicker.value = '0000-02-03T08:30:00';
          expect(dateTimePicker.__selectedDateTime).to.eql(date);

          date.setFullYear(10000);
          dateTimePicker.value = '+010000-02-03T08:30:00';
          expect(dateTimePicker.__selectedDateTime).to.eql(date);

          date.setFullYear(-10000);
          dateTimePicker.value = '-010000-02-03T08:30:00';
          expect(dateTimePicker.__selectedDateTime).to.eql(date);
        });

        it('should not accept non-ISO formats', () => {
          const invalidValues = [
            '03/02/01T08:30',
            '2010/02/03T08:30',
            '03/02/2010T08:30',
            '3 Feb 2010T08:30',
            'Feb 3, 2010T08:30',
            '2019-09-19T08.30'
          ];
          for (const invalidValue of invalidValues) {
            dateTimePicker.value = invalidValue;
            expect(dateTimePicker.value).to.equal('');
            expect(dateTimePicker.__selectedDateTime).to.equal('');
          }
        });

        it('should output ISO format', () => {
          var date = new Date(0, 1, 3, 8, 30, 0);

          date.setFullYear(0);
          dateTimePicker.__selectedDateTime = date;
          expect(dateTimePicker.value).to.equal('0000-02-03T08:30');

          dateTimePicker.step = 1;
          expect(dateTimePicker.value).to.equal('0000-02-03T08:30:00');
          // test that format stays even after setting the value again
          dateTimePicker.value = '';
          dateTimePicker.__selectedDateTime = date;
          expect(dateTimePicker.value).to.equal('0000-02-03T08:30:00');

          dateTimePicker.step = .001;
          expect(dateTimePicker.value).to.equal('0000-02-03T08:30:00.000');
          // test that format stays even after setting the value again
          dateTimePicker.value = '';
          dateTimePicker.__selectedDateTime = date;
          expect(dateTimePicker.value).to.equal('0000-02-03T08:30:00.000');

          date.setFullYear(10000);
          dateTimePicker.step = undefined;
          dateTimePicker.__selectedDateTime = new Date(date.getTime());
          expect(dateTimePicker.value).to.equal('+010000-02-03T08:30');
          dateTimePicker.step = 1;
          expect(dateTimePicker.value).to.equal('+010000-02-03T08:30:00');
          dateTimePicker.step = .001;
          expect(dateTimePicker.value).to.equal('+010000-02-03T08:30:00.000');

          date.setFullYear(-10000);
          dateTimePicker.step = undefined;
          dateTimePicker.__selectedDateTime = new Date(date.getTime());
          expect(dateTimePicker.value).to.equal('-010000-02-03T08:30');
          dateTimePicker.step = 1;
          expect(dateTimePicker.value).to.equal('-010000-02-03T08:30:00');
          dateTimePicker.step = .001;
          expect(dateTimePicker.value).to.equal('-010000-02-03T08:30:00.000');
        });

        it('should allow millisecond precision values', () => {
          dateTimePicker.step = .5;
          const testValue = '2020-01-09T12:34:56.789';
          dateTimePicker.value = testValue;
          expect(dateTimePicker.value).to.equal(testValue);
        });

      });

    });

    describe('Initial value', () => {
      let dateTimePicker;
      let customField;

      beforeEach(() => {
        dateTimePicker = fixture('initial-value');
        customField = dateTimePicker.$.customField;
      });

      it('should use initial value from attribute without clearing it', () => {
        expect(dateTimePicker.value).to.equal('2019-09-16T15:00');
        expect(customField.value).to.equal('2019-09-16T15:00');
      });

    });

    describe('Theme attribute', () => {
      let dateTimePicker;
      let customField;
      let datePicker;
      let timePicker;

      beforeEach(() => {
        dateTimePicker = fixture('theme-attribute');
        customField = dateTimePicker.$.customField;
        datePicker = customField.inputs[0];
        timePicker = customField.inputs[1];
      });

      it('should propagate theme attribute to custom-field', () => {
        expect(customField.getAttribute('theme')).to.equal('foo');
      });

      it('should propagate theme attribute to date-picker', () => {
        expect(datePicker.getAttribute('theme')).to.equal('foo');
      });

      it('should propagate theme attribute to time-picker', () => {
        expect(timePicker.getAttribute('theme')).to.equal('foo');
      });

    });

    ['default', 'lazy'].forEach(set => {
      describe(`Slotted inputs (${set})`, () => {
        let dateTimePicker;
        let customField;
        let datePicker;
        let timePicker;

        beforeEach(done => {
          if (set === 'default') {
            dateTimePicker = fixture('slotted-inputs');
          } else if (set === 'lazy') {
            dateTimePicker = fixture('lazy-slotted-inputs');
          }
          customField = dateTimePicker.$.customField;
          datePicker = dateTimePicker.querySelector('vaadin-date-picker');
          timePicker = dateTimePicker.querySelector('vaadin-time-picker');
          if (set === 'lazy') {
            // Assign the slots lazily simulating the case if Flow adds the slotted elements after date time picker is ready
            datePicker.slot = 'date-picker';
            timePicker.slot = 'time-picker';
            setTimeout(() => done(), 0);
          } else {
            done();
          }
        });

        it('should have correct inputs set in custom-field', () => {
          expect(customField.inputs[0]).to.equal(datePicker);
          expect(customField.inputs[1]).to.equal(timePicker);
        });

        it('should propagate value to slotted inputs', () => {
          dateTimePicker.value = '2019-09-16T15:00';
          expect(datePicker.value).to.equal('2019-09-16');
          expect(timePicker.value).to.equal('15:00');

          dateTimePicker.value = '';
          expect(datePicker.value).to.equal('');
          expect(timePicker.value).to.equal('');
        });

        it('should get value from slotted inputs', () => {
          datePicker.value = '2019-09-16';
          timePicker.value = '15:00';
          dateTimePicker.__triggerCustomFieldValueUpdate();
          expect(dateTimePicker.value).to.equal('2019-09-16T15:00');

          datePicker.value = '';
          dateTimePicker.__triggerCustomFieldValueUpdate();
          expect(dateTimePicker.value).to.equal('');
        });

        describe('Removing change listeners', () => {

          it('should remove change listener from removed date picker', done => {
            dateTimePicker.removeChild(datePicker); // Remove slotted date picker
            setTimeout(() => {
              changeInputValue(datePicker, '2019-09-16');
              expect(dateTimePicker.__doDispatchChange).to.be.not.true;
              done();
            }, 0);
          });

          it('should remove change listener from removed time picker', done => {
            dateTimePicker.removeChild(timePicker); // Remove slotted time picker
            setTimeout(() => {
              changeInputValue(timePicker, '15:00');
              expect(dateTimePicker.__doDispatchChange).to.be.not.true;
              done();
            }, 0);
          });

        });
      });
    });

    ['default', 'lazy'].forEach(set => {
      describe(`Initial value from slotted inputs (${set})`, () => {
        let dateTimePicker;
        let customField;

        beforeEach(done => {
          if (set === 'default') {
            dateTimePicker = fixture('slotted-values');
            customField = dateTimePicker.$.customField;
            done();
          } else if (set === 'lazy') {
            dateTimePicker = fixture('lazy-slotted-values');
            customField = dateTimePicker.$.customField;
            // Assign the slots lazily simulating the case if Flow adds the slotted elements after date time picker is ready
            dateTimePicker.querySelector('vaadin-date-picker').slot = 'date-picker';
            dateTimePicker.querySelector('vaadin-time-picker').slot = 'time-picker';
            setTimeout(() => done(), 0);
          }
        });

        // This test simulates how DatePicker sets the initial value from server side
        it('should get initial value from slotted inputs', () => {
          expect(customField.value).to.equal('2019-09-16T15:00');
          expect(dateTimePicker.value).to.equal('2019-09-16T15:00');
        });

      });
    });
  </script>
</body>
